<!DOCTYPE html>
<html lang="zh-CN">
 <head>
     <meta charset="utf-8" />
  <title>浅谈线段树 | LewisLi的博客 | I AK IOI</title>
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
  <link rel="stylesheet" href="https://Lewis-Li-lyf.github.io/styles/main.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
   <script src="https://cdn.staticfile.org/highlight.js/9.15.9/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
 </head>
 <body>
     <div class="sidebar animated fadeInDown">
   <div class="logo-title">
    <div class="title">
     <img src="https://Lewis-Li-lyf.github.io/images/avatar.png?v=1583583402880" style="width:127px;" />

     <h3 title=""><a href="/">LewisLi</a></h3>

     <div class="description">
      <p>Aho-Corasick automaton的fail树上dfs序建可持久化线段树也很棒呢~</p>
     </div>
    </div>
   </div>
   <ul class="social-links">


    

    

    

    <li><a href="https://github.com/Lewis-Li-lyf"><i class="fa fa-github"></i></a></li>
 
    

    

    

    

    

    <li><a href="85528116"><i class="fa fa-qq"></i></a></li>
 
    

    

   </ul>
   <div class="footer">
    <div class="by_farbox">
   Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
    </div>
    

    </div>
   </div>
  </div>
  <div class="main">
     <div class="page-top animated fadeInDown">
    <div class="nav">
    
     <li><a  href="/">首页</a></li>

     <li><a  href="/archives">归档</a></li>

     <li><a  href="/tags">标签</a></li>

     <li><a  href="/post/about">关于</a></li>

    </div>
    <div class="information">
     <div class="back_btn">
      <li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li>
     </div>
    </div>
   </div>
   <div class="autopagerize_page_element">
    <div class="content">
     <div class="post-page">
      <div class="post animated fadeInDown">
       <div class="post-title">
        <h3><a>浅谈线段树</a></h3>
       </div>
       <div class="post-content">
        <h1 id="介绍">介绍</h1>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。它的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界。</p>
<p>使用线段树可以快速的查找某一个节点在若干条线段中出现的次数。</p>
<h1 id="结构与建立">结构与建立</h1>
<p>线段树是建立在线段的基础上，每一个节点代表了一条线段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>的长度。若一个节点代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，则它的 2 个儿子分别代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>a</mi><mo separator="true">,</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mo>÷</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(a,(a+b) \div 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mo>÷</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>b</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">((a+b) \div 2+1,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span> 。若一个节点的编号为 i ，那么它的 2 个儿子的编号分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i  \times 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \times 2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。用位运算优化后就是 i&lt;&lt;1，i&lt;&lt;1|1 。</p>
<p>建立时，从根节点向下遍历。如果它是一个叶节点，则对其赋值并返回，如果不是，分别像两边延展，返回时计算其值。<br>
本文中<code>k</code>都表示节点编号，<code>l</code>，<code>r</code>代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(l,r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>。</p>
<pre><code>const int maxn = 100010;
int a[maxn];
struct node{
	int l,r;//左区间和右区间
	int sum,lz;//节点的值和 lazytage，用于区间修改和查询
}t[maxn*4+2];

void build(int k,int l,int r){
	t[k].l=l , t[k].r=r;
	if(l==r){//是叶节点
		t[k].sum=a[l];
		return ;
	}
	int mid=(l+r)&gt;&gt;1;
	build(k&lt;&lt;1,l,mid) , build(k&lt;&lt;1|1,mid+1,r);//向两侧递归
	t[k].sum=t[k&lt;&lt;1].sum+t[k&lt;&lt;1|1].sum;//计算节点的值
	return ;
}
</code></pre>
<h1 id="区间修改区间查询">区间修改，区间查询</h1>
<p>这里就不讲单点的那些了，不然你为什么要用线段树，树状数组不香吗？</p>
<p>先来解决第一步：<br>
我们先从根节点出发（根节点一定包含所有的点，包括被修改区间），一直往下走，直到当前区间中的元素全部都是被修改元素。<br>
当左区间包含整个被修改区间时，我们就递归到左区间；<br>
当右区间包含整个被修改区间时，我们就递归到右区间；<br>
但是，我们似乎漏了一种情况：<br>
<img src="https://img-blog.csdn.net/20180820161515555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nemloYW9hbA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" loading="lazy"><br>
这样该怎么办呢？<br>
我们从 mid 切开，发现 2 个区间就都刚好对应了。分别向 2 个区间递归即可。<br>
那么我们怎么去修改它们呢？肯定不能像建树那样遍历，所以我们引进一个<strong>新的，高大上</strong>的东西——<strong>lazytage懒标记</strong>。在修改的时候，先对这个区间修改，之后对其子节点打上懒标记。等到需要的时候，再进行修改。<br>
那么就涉及到一个懒标记下传的问题。这个操作叫做 pushdown。在修改和查询的时候，一定不能忘记。</p>
<pre><code>void Pushdown(int k){
	if(t[k].l==t[k].r){
		t[k].lz=0;
		return ;
	}
	t[k&lt;&lt;1].sum+=t[k].lz*(t[k&lt;&lt;1].r-t[k&lt;&lt;1].l+1);
	t[k&lt;&lt;1|1].sum+=t[k].lz*(t[k&lt;&lt;1|1].r-t[k&lt;&lt;1|1].l+1);
	t[k&lt;&lt;1].lz+=t[k].lz;//下传
	t[k&lt;&lt;1|1].lz+=t[k].lz;
	t[k].lz=0;//记得懒标记打完时候清零
	return ;
}
</code></pre>
<pre><code>void update(int k,int l,int r,int x){//x指要增加的值
	if(l==t[k].l &amp;&amp; r==t[k].r){
		t[k].sum+=(r-l+1)*x;
		t[k].lz+=x;//找到匹配区间，打上懒标记
		return ;
	}
	Pushdown(k);//一定不能忘！！！
	int mid=(t[k].l+t[k].r)&gt;&gt;1;
	if(r&lt;=mid) update(k&lt;&lt;1,l,r,x);//左儿子
	else if(l&gt;mid) update(k&lt;&lt;1|1,l,r,x);//右儿子
	else update(k&lt;&lt;1,l,mid,x),update(k&lt;&lt;1|1,mid+1,r,x);//从中间切开
	t[k].sum=t[k&lt;&lt;1].sum+t[k&lt;&lt;1|1].sum;//更新
	return ;
}
</code></pre>
<p>接下来是查询。<br>
查询很简单，就是向下搜索。如果找到了刚好匹配的区间，就返回它。如果不是，则继续向下搜索。</p>
<pre><code>int query(int k,int l,int r){
	if(l==t[k].l &amp;&amp; r==t[k].r) return t[k].sum;//匹配区间
	Pushdown(k);
	int mid=(t[k].l+t[k].r)&gt;&gt;1;
	if(r&lt;=mid) return query(k&lt;&lt;1,l,r);//完全处于左儿子
	if(l&gt;mid) return query(k&lt;&lt;1|1,l,r);//完全处于右儿子
	return query(k&lt;&lt;1,l,mid)+query(k&lt;&lt;1|1,mid+1,r);//左右都有，分别像两边搜索
}
</code></pre>

       </div>
       <div class="post-footer">
        <div class="meta">
         <div class="info">
          <i class="fa fa-sun-o"></i>
          <span class="date">2020-03-06</span>
          <i class="fa fa-tag"></i>
          
          <a class="tag" href="https://Lewis-Li-lyf.github.io/tag/lkI9ZNq5F/" title="算法">算法 </a>
          
         </div>
        </div>
       </div>
      </div>
      <div class="share">
       <div class="evernote">
        <a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a>
       </div>
       <div class="weibo">
        <a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a>
       </div>
       <div class="twitter">
        <a class="fa fa-twitter" href="http://twitter.com/home?status=,https://Lewis-Li-lyf.github.io/post/qian-tan-xian-duan-shu/,;"></a>
       </div>
      </div>
      <div class="pagination">
       <ul class="clearfix">

        <li class="pre pagbuttons"><a class="btn" role="navigation" href="https://Lewis-Li-lyf.github.io/post/iostream-shu-ru-shu-chu-liu/" title="iostream 输入输出流">上一篇</a></li>
         
        
        <li class="next pagbuttons"><a class="btn" role="navigation" href="https://Lewis-Li-lyf.github.io/post/shu-xue-gong-shi-chang-shi/" title=" 数学公式尝试">下一篇</a></li>
        
       </ul>
      </div>
        
     </div>
    </div>
   </div>
  </div>
  <script src="https://Lewis-Li-lyf.github.io/media/scripts/jquery.js"></script>
  <script src="https://Lewis-Li-lyf.github.io/media/scripts/jquery-migrate-1.2.1.min.js"></script>
  <script src="https://Lewis-Li-lyf.github.io/media/scripts/jquery.appear.js"></script>


 </body>
</html>