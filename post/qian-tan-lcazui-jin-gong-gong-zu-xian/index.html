<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>浅谈 LCA（最近公共祖先） | LewisLi的博客 | I AK IOI</title>
<link rel="shortcut icon" href="https://Lewis-Li-lyf.github.io/favicon.ico?v=1586420450993">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://Lewis-Li-lyf.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="浅谈 LCA（最近公共祖先） | LewisLi的博客 | I AK IOI - Atom Feed" href="https://Lewis-Li-lyf.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="关于 LCA 是什么，我就不再叙述了。请出门右转自行百度。
如果本文介绍的不是很清楚，请移步至这篇文章。
寻找 LCA 的方法：
朴素算法
这是最简单的 LCA 算法，也是学习倍增算法前重要的一环。

假如我们现在要求两个点的 LCA，我们..." />
    <meta name="keywords" content="C++,算法" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://Lewis-Li-lyf.github.io">
  <img class="avatar" src="https://Lewis-Li-lyf.github.io/images/avatar.png?v=1586420450993" alt="">
  </a>
  <h1 class="site-title">
    LewisLi的博客 | I AK IOI
  </h1>
  <p class="site-description">
    临兵斗者，皆阵列在前！
<link rel="stylesheet" type="text/css" href="https://files.cnblogs.com/files/kousak/waifu.css">
    <div class="waifu" id="waifu">
        <div class="waifu-tips" style="opacity: 1;"></div>
        <canvas id="live2d" width="280" height="250" class="live2d"></canvas>
        <div class="waifu-tool">
            <span class="fui-home"></span>
            <span class="fui-chat"></span>
            <span class="fui-eye"></span>
            <span class="fui-user"></span>
            <span class="fui-photo"></span>
            <span class="fui-info-circle"></span>
            <span class="fui-cross"></span>
        </div>
    </div>
    <script src="https://files.cnblogs.com/files/kousak/live2d.js"></script>
    <script src="https://files.cnblogs.com/files/kousak/waifu-tips.js"></script>
    <script type="text/javascript">initModel()</script>
<link rel="stylesheet" type="text/css" href="https://files.cnblogs.com/files/kousak/waifu.css"/>
    <script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="https://files.cnblogs.com/files/yjlblog/flat-ui.min.css"/>
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://Lewis-Li-lyf.github.io/post/about-me" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Lewis-Li-lyf" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              浅谈 LCA（最近公共祖先）
            </h2>
            <div class="post-info">
              <span>
                2020-03-20
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://Lewis-Li-lyf.github.io/tag/1Zvs2DC7H/" class="post-tag">
                  # C++
                </a>
              
                <a href="https://Lewis-Li-lyf.github.io/tag/lkI9ZNq5F/" class="post-tag">
                  # 算法
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>关于 LCA 是什么，我就不再叙述了。请出门右转自行百度。<br>
如果本文介绍的不是很清楚，请移步至<a href="https://blog.csdn.net/Q_M_X_D_D_/article/details/89924963">这篇文章</a>。</p>
<p><strong>寻找 LCA 的方法：</strong></p>
<h1 id="朴素算法">朴素算法</h1>
<p>这是最简单的 LCA 算法，也是学习倍增算法前重要的一环。<br>
<img src="https://img-blog.csdn.net/20170310105229935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjkyODMyNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="来看一下这张图" loading="lazy"><br>
假如我们现在要求两个点的 LCA，我们可以这样做：<br>
求 LCA，最直接的就是让他们一步一步向上“爬”，当他们相交时，这个交点便是这两个点的 LCA<s>给爷爪巴</s>。<br>
但是，在向上爬的时候，我们要保证一件事情，那就是，我们必须让两个点处在同一深度。否则，这两个点永远不会相交。因为，既然他们不在同一深度上，他们在爬的过程中始终有深度差，那怎么会相交呢？<br>
这种算法很好写也很好理解，只需要进行一次深搜，记录每个点的父节点和它的深度，就可以进行查询了。<br>
但是有一个问题：<br>
太慢了！<br>
于是，我们可以用<strong>倍增</strong>来优化</p>
<h1 id="倍增算法">倍增算法</h1>
<h2 id="算法思想">算法思想</h2>
<p>既然一次跳一步太慢了，我们就一次跳多步。<br>
跳多少步呢？<br>
我们可以跳<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>步。<br>
我们看这个序列：</p>
<blockquote>
<p>1,2,4,8,16,32,……</p>
</blockquote>
<p>我们可以用这个序列中的数字表示每一个正整数。<br>
而且，每个数字只用1次。<br>
这是倍增算法的第一个关键理论。<br>
第二个关键理论是：</p>
<blockquote>
<p>如果c是a和b的LCA，那么c的所有祖先同样也是a和b的公共祖先，但不是最近的。</p>
</blockquote>
<p>也就是说，我们可以步步逼近这个 LCA 。如果走这一步重合了，我们就知道这是他们的公共祖先。如果没重合，就往上爬。最后两个点会爬到 LCA 的下一层。他们的父亲节点即是 LCA 。</p>
<h2 id="算法实现">算法实现</h2>
<h3 id="dep数组和dp数组">dep数组和dp数组</h3>
<p>这里有一个很重要的东西，就是我们要知道一个点上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>层的祖先是谁。这里我们引入一个 DP 数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">P</mi><mo>[</mo><mi mathvariant="normal">i</mi><mo>]</mo><mo>[</mo><mi mathvariant="normal">j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">\rm{DP[i][j]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mopen">[</span><span class="mord mathrm">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">j</span><span class="mclose">]</span></span></span></span></span></span>，表示节点 i 上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span> 层的祖先，<strong>j 为 0 时即代表它的父亲</strong>。如：DP[F][0]是 D，DP[H][1]是 D，DP[I][2]是 A。当然，在题目中这些字母将替换成数字。<br>
那么我们怎么求出这个<s>玄学的</s> DP 数组呢？<br>
我们先 dfs 求出每个节点的父节点，然后，得出以下递推式：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">P</mi><mo>[</mo><mi mathvariant="normal">i</mi><mo>]</mo><mo>[</mo><mi mathvariant="normal">j</mi><mo>]</mo><mo>=</mo><mi mathvariant="normal">D</mi><mi mathvariant="normal">P</mi><mo>[</mo><mi mathvariant="normal">D</mi><mi mathvariant="normal">P</mi><mo>[</mo><mi mathvariant="normal">i</mi><mo>]</mo><mo>[</mo><mi mathvariant="normal">j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>]</mo><mo>[</mo><mi mathvariant="normal">j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">\rm{DP[i][j] = DP[DP[i][j-1]][j-1]}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mopen">[</span><span class="mord mathrm">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mopen">[</span><span class="mord mathrm">D</span><span class="mord mathrm">P</span><span class="mopen">[</span><span class="mord mathrm">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathrm">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathrm">1</span><span class="mclose">]</span></span></span></span></span></span></p>
<p>这个式子不难理解，表示的是 i 节点上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>的祖先为 i 节点上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的祖先的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{j-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的祖先。<s>（真拗口）</s><br>
结合代码理解一下：</p>
<pre><code class="language-cpp">void dfs(int x,int pre){//x代表节点，pre代表前驱结点（即父节点）
    dep[x] = dep[pre] + 1;//确定深度
    dp[x][0] = pre;//确定父亲
    for(int i=1;(1&lt;&lt;i)&lt;=dep[x];i++){
        dp[x][i] = dp[dp[x][i-1]][i-1];//确定DP数组。因为是向下搜索，所以不会出问题。可以直接推一下
    }
    for(int i=head[x];i!=-1;i=edge[i].next){//链式前向星存图
        if(edge[i].to != pre){
            dfs(edge[i].to,x);
        }
    }
}
</code></pre>
<h3 id="查询">查询</h3>
<p>有了 DP 数组，查询就很容易理解了，与朴素算法差不多，具体在代码中解释：</p>
<pre><code class="language-cpp">int LCA(int a,int b){
    if(dep[a] &lt; dep[b]){//保证a的深度大于b的深度，可以理解为“不妨设节点a的深度大于节点b的深度”
        swap(a,b);
    }
    for(int i=20;i&gt;=0;i--){//让两节点处于同一深度
        if(dep[a] - (1 &lt;&lt; i) &gt;= dep[b])
            a = dp[a][i];
    }
    if(a == b){//如果相同，说明重合了，直接返回
        return a;
    }
    for(int i=20;i&gt;=0;i--){//向上“爬”
        if(dp[a][i] != dp[b][i]){//如果相等，说明这个节点是他们的公共祖先，只不过不一定是最近的。
            a = dp[a][i],b = dp[b][i];
        }
    }//最后会爬到LCA的下一层，a、b都是LCA的儿子，他们的父亲即是LCA。
    return dp[a][0];
}
</code></pre>
<p>至此，整个倍增求解 LCA 就完成了。<br>
放上完整代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;

const int maxn = 500005;
int n,m,s;//n个节点，m个询问，根为s
int dep[maxn],dp[maxn][21];
//链式前向星
int head[maxn];
struct node{
    int to,next;
}edge[maxn*2];//无向图，开两倍
int cnt = 0;
void add(int from,int t){
    edge[cnt].to = t;
    edge[cnt].next = head[from];
    head[from] = cnt++;
}

void dfs(int x,int pre){//x代表节点，pre代表前驱结点（即父节点）
    dep[x] = dep[pre] + 1;//确定深度
    dp[x][0] = pre;//确定父亲
    for(int i=1;(1&lt;&lt;i)&lt;=dep[x];i++){
        dp[x][i] = dp[dp[x][i-1]][i-1];//确定DP数组。因为是向下搜索，所以不会出问题。可以直接推一下
    }
    for(int i=head[x];i!=-1;i=edge[i].next){//链式前向星存图
        if(edge[i].to != pre){
            dfs(edge[i].to,x);
        }
    }
}
int LCA(int a,int b){
    if(dep[a] &lt; dep[b]){//保证a的深度大于b的深度，可以理解为“不妨设节点a的深度大于节点b的深度”
        swap(a,b);
    }
    for(int i=20;i&gt;=0;i--){//让两节点处于同一深度
        if(dep[a] - (1 &lt;&lt; i) &gt;= dep[b])
            a = dp[a][i];
    }
    if(a == b){//如果相同，说明重合了，直接返回
        return a;
    }
    for(int i=20;i&gt;=0;i--){//向上“爬”
        if(dp[a][i] != dp[b][i]){//如果相等，说明这个节点是他们的公共祖先，只不过不一定是最近的。
            a = dp[a][i],b = dp[b][i];
        }
    }//最后会爬到LCA的下一层，a、b都是LCA的儿子，他们的父亲即是LCA。
    return dp[a][0];
}
int main(){
    memset(head,-1,sizeof(head));
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
    for(int i=1;i&lt;n;i++){
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        add(x,y),add(y,x);//无向图，存两次
    }
    dfs(s,0);
    for(int i=1;i&lt;=m;i++){//查询
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        printf(&quot;%d\n&quot;,LCA(x,y));
    }
    return 0;
}</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E6%9C%B4%E7%B4%A0%E7%AE%97%E6%B3%95">朴素算法</a></li>
<li><a href="#%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95">倍增算法</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">算法实现</a>
<ul>
<li><a href="#dep%E6%95%B0%E7%BB%84%E5%92%8Cdp%E6%95%B0%E7%BB%84">dep数组和dp数组</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2">查询</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://Lewis-Li-lyf.github.io/post/iostream-shu-ru-shu-chu-liu/">
              <h3 class="post-title">
                转载：iostream 输入输出流
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '69f5ad5fbcf93f9cc9d6',
    clientSecret: '61a7c29e2ca8a20c7c9bd34d002e625033ccd557',
    repo: 'Lewis-Li-lyf.github.io',
    owner: 'Lewis-Li-lyf',
    admin: ['Lewis-Li-lyf'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by<a href="https://github.com/getgridea/gridea" target="_blank">Gridea </a>
<div style = "display:none;" > 浏览器标题切换  </div>
<script>  
    var OriginTitile = document.title;    // 保存之前页面标题  
    var titleTime;  
    document.addEventListener('visibilitychange', function(){  
        if (document.hidden){  
            document.title ='你不要我了嘛QAQ';  // 切出文字
            clearTimeout(titleTime);  
        }else{  
            document.title = '我是个蒟蒻QAQ';  // 切入文字
            titleTime = setTimeout(function() {  
                document.title = OriginTitile;  
            }, 1000); // 2秒后恢复原标题  
        }  
    });  
    </script>
<div class="site-footer">
  <span id="timeDate">载入天数...载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("03/05/2020 00:00:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "我的博客已安全运行 "+dnum+" 天 " + hnum + " 小时 " + mnum + " 分 " + snum + " 秒";  
    } 
setInterval("createtime()",250);
</script>
<!-- 鼠标点击特效 -->
<script src="https://example.com/cursor-effects.js"></script>
<!-- 鼠标点击特效end -->
<script type="text/javascript" color="0,0,255" opacity='0.7' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script>
<script type="text/javascript"> 
 
!function (e, t, a) {function r() {for (var e = 0; e < s.length; e++) s[e].alpha <= 0 ? (t.body.removeChild(s[e].el), s.splice(e, 1)) : (s[e].y--, s[e].scale += .004, s[e].alpha -= .013, s[e].el.style.cssText = "left:" + s[e].x + "px;top:" + s[e].y + "px;opacity:" + s[e].alpha + ";transform:scale(" + s[e].scale + "," + s[e].scale + ") rotate(45deg);background:" + s[e].color + ";z-index:99999");requestAnimationFrame(r)}function n() {var t = "function" == typeof e.onclick && e.onclick;e.onclick = function (e) {t && t(), o(e)}}function o(e) {var a = t.createElement("div");a.className = "heart", s.push({el: a,x: e.clientX - 5,y: e.clientY - 5,scale: 1,alpha: 1,color: c()}), t.body.appendChild(a)}function i(e) {var a = t.createElement("style");a.type = "text/css";try {a.appendChild(t.createTextNode(e))} catch (t) {a.styleSheet.cssText = e}t.getElementsByTagName("head")[0].appendChild(a)}function c() {return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"}var s = [];e.requestAnimationFrame = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) {setTimeout(e, 1e3 / 60)}, i(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"), n(), r()}(window, document);
</script>
<script>
function clickEffect() {
    let balls = [];
    let longPressed = false;
    let longPress;
    let multiplier = 0;
    let width, height;
    let origin;
    let normal;
    let ctx;
    const colours = ["#F73859", "#14FFEC", "#00E0FF", "#FF99FE", "#FAF15D"];
    const canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.setAttribute("style", "width: 100%; height: 100%; top: 0; left: 0; z-index: 99999; position: fixed; pointer-events: none;");
    const pointer = document.createElement("span");
    pointer.classList.add("pointer");
    document.body.appendChild(pointer);

    if (canvas.getContext && window.addEventListener) {
        ctx = canvas.getContext("2d");
        updateSize();
        window.addEventListener('resize', updateSize, false);
        loop();
        window.addEventListener("mousedown", function(e) {
            pushBalls(randBetween(10, 20), e.clientX, e.clientY);
            document.body.classList.add("is-pressed");
            longPress = setTimeout(function() {
                document.body.classList.add("is-longpress");
                longPressed = true;
            }, 500);
        }, false);
        window.addEventListener("mouseup", function(e) {
            clearInterval(longPress);
            if (longPressed == true) {
                document.body.classList.remove("is-longpress");
                pushBalls(randBetween(50 + Math.ceil(multiplier), 100 + Math.ceil(multiplier)), e.clientX, e.clientY);
                longPressed = false;
            }
            document.body.classList.remove("is-pressed");
        }, false);
        window.addEventListener("mousemove", function(e) {
            let x = e.clientX;
            let y = e.clientY;
            pointer.style.top = y + "px";
            pointer.style.left = x + "px";
        }, false);
    } else {
        console.log("canvas or addEventListener is unsupported!");
    }


    function updateSize() {
        canvas.width = window.innerWidth * 2;
        canvas.height = window.innerHeight * 2;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(2, 2);
        width = (canvas.width = window.innerWidth);
        height = (canvas.height = window.innerHeight);
        origin = {
            x: width / 2,
            y: height / 2
        };
        normal = {
            x: width / 2,
            y: height / 2
        };
    }
    class Ball {
        constructor(x = origin.x, y = origin.y) {
            this.x = x;
            this.y = y;
            this.angle = Math.PI * 2 * Math.random();
            if (longPressed == true) {
                this.multiplier = randBetween(14 + multiplier, 15 + multiplier);
            } else {
                this.multiplier = randBetween(6, 12);
            }
            this.vx = (this.multiplier + Math.random() * 0.5) * Math.cos(this.angle);
            this.vy = (this.multiplier + Math.random() * 0.5) * Math.sin(this.angle);
            this.r = randBetween(8, 12) + 3 * Math.random();
            this.color = colours[Math.floor(Math.random() * colours.length)];
        }
        update() {
            this.x += this.vx - normal.x;
            this.y += this.vy - normal.y;
            normal.x = -2 / window.innerWidth * Math.sin(this.angle);
            normal.y = -2 / window.innerHeight * Math.cos(this.angle);
            this.r -= 0.3;
            this.vx *= 0.9;
            this.vy *= 0.9;
        }
    }

    function pushBalls(count = 1, x = origin.x, y = origin.y) {
        for (let i = 0; i < count; i++) {
            balls.push(new Ball(x, y));
        }
    }

    function randBetween(min, max) {
        return Math.floor(Math.random() * max) + min;
    }

    function loop() {
        ctx.fillStyle = "rgba(255, 255, 255, 0)";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = 0; i < balls.length; i++) {
            let b = balls[i];
            if (b.r < 0) continue;
            ctx.fillStyle = b.color;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2, false);
            ctx.fill();
            b.update();
        }
        if (longPressed == true) {
            multiplier += 0.2;
        } else if (!longPressed && multiplier >= 0) {
            multiplier -= 0.4;
        }
        removeBall();
        requestAnimationFrame(loop);
    }

    function removeBall() {
        for (let i = 0; i < balls.length; i++) {
            let b = balls[i];
            if (b.x + b.r < 0 || b.x - b.r > width || b.y + b.r < 0 || b.y - b.r > height || b.r < 0) {
                balls.splice(i, 1);
            }
        }
    }
}
clickEffect();//调用
</script>
<style>
.pointer {
    --size:30px;pointer-events: none;
    width: var(--size);
    height: var(--size);
    background: rgba(247,56,89,0.2);
    position: fixed;
    border-radius: 50%;
    transform: translate3d(-50%,-50%,0) scale(0);
    transition: transform 0.3s;
    border: 2px solid rgba(247,56,89,0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
}

.pointer:before {
    content: "";
    width: 80%;
    height: 80%;
    position: absolute;
    display: block;
    background: none;
    border-radius: 50%;
    transition: background 0.5s,box-shadow 0.5s;
}

.is-pressed .pointer {
    transform: translate3d(-50%,-50%,0) scale(1);
}

.is-longpress .pointer {
    animation: wobble 0.2s infinite alternate;
}

.is-longpress .pointer:before {
    background: #faf15d;
    box-shadow: 0 0 5px rgba(250,241,93,0.5);
    animation: wobble2 0.2s infinite alternate;
}

@keyframes wobble {
    to {
        transform: translate3d(-50%,-50%,0) scale(0.5);
    }
}

@keyframes wobble2 {
    to {
        transform: scale(0.5);
    }
}
</style>
  <a class="rss" href="https://Lewis-Li-lyf.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
