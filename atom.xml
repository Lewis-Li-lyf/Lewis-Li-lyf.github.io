<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://lewis-li-lyf.github.io</id>
    <title>LewisLi的博客 | I AK IOI</title>
    <updated>2020-05-01T02:38:50.069Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://lewis-li-lyf.github.io"/>
    <link rel="self" href="https://lewis-li-lyf.github.io/atom.xml"/>
    <subtitle>临兵斗者，皆阵列在前！</subtitle>
    <logo>https://lewis-li-lyf.github.io/images/avatar.png</logo>
    <icon>https://lewis-li-lyf.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, LewisLi的博客 | I AK IOI</rights>
    <entry>
        <title type="html"><![CDATA[转载：写给 OIer 们的一些话]]></title>
        <id>https://lewis-li-lyf.github.io/post/Something-to-tell-the-OIers/</id>
        <link href="https://lewis-li-lyf.github.io/post/Something-to-tell-the-OIers/">
        </link>
        <updated>2020-04-20T06:07:57.000Z</updated>
        <content type="html"><![CDATA[<p>转载自<a href="https://www.cnblogs.com/mathematician/p/12633276.html"></a><br>
<a href="https://www.luogu.com.cn/discuss/show/216846"></a></p>
<p>我是一个高二的OIer，离我正式退役的日子已经不超过一年了。在这个时期，与其写一些回忆性的文字，不如跳出“自我”的范畴，以一种比较全局的角度和大家一起分享一些我对OI的认知和看法。目的是让初三高一的学弟学妹看清眼前的路，让高二高三的人了解自己走过的足迹。</p>
<h1 id="独特的模式">独特的模式</h1>
<h2 id="知识的更新">知识的更新</h2>
<p>我们先从OI的比赛日程谈起。选手获得NOIP一等奖后，可以报名参加WC（时间为1-2月）。而在5月，选手即使没有通过省选进入省队，也可以报名参加CTS(C)。其中WC和CTS(C)不仅是信息集训队的两轮选拔，也是非集训队选手得奖的机会。而每年的WC，都会安排集训队选手和前集训队选手进行授课。每年的CTS(C)，会安排候选队选手（去年是候选队前6）来进行英语自我介绍和论文答辩，这一项的分数是要按一定权重计入集训选拔分数的。对于一个集训队选手来说，他不仅需要完成题目，还必须写一篇关于集训队作业某些题的解题报告，甚至可能需要写命题报告。如果他进入候选队，那么他必须写一篇候选队论文。有时候选队15人会组成小组互相出题给对方做，这被称为候选队互测。</p>
<p>撇去“收钱”的原因，为什么CCF要这么安排？因为CCF明白<strong>OI的知识范围的更新只能靠水平较高的优秀选手来完成，之后服务OI的主力军也是他们</strong>，而WC和CTS正是新的知识点向各个选手普及的过程。例如：2008年陈丹琪论文中出现了cdq分治，WC2012的陈立杰的《后缀自动机》讲稿，在2013候选队论文《浅谈数据结构的几个非经典解法》中出现的二进制分组的思想，在2015集训队论文出现的多项式求逆、ln、exp等技巧，以及在2019年WC讲授的模拟费用流问题。硬性规定的解题报告、命题报告，是对他们之后出题工作的一个很好的训练。</p>
<p>那些新潮的知识点会借助互联网的平台逐步往下传。一开始在那些大佬们的博客中出现，然后是一些高层次的比赛的题目（比如WC，CTS），接着是很多强校的模拟赛，最后就是NOI、省选、NOIP的真题了。在传递过程中，这些idea会经历一定时间的考验和衡量。最后我们留下那些能简化代码量的、对某些问题非常适用的、具有考察价值的知识点，在1-5年的时间内成为我们必须要学习的内容。</p>
<p>这样的安排无疑带来了非常好的效果，给OI的知识体系增添了活力。唯一美中不足的是：缺少能看懂候选队论文的评委。每次答辩的时候，评委总是会问一些质量不高、无关紧要的问题。也许是因为CCF也知道这一点，除了一些极端情况外，候选队论文答辩的分数不影响最终国家队的名单。</p>
<h2 id="命题的故事">命题的故事</h2>
<p>那些集训队选手毕业后一部分会加入清华或北大的算法协会，在1-5年后成为比赛出题人。命题的工作需要寻找一个“灵感”，就是这道题的核心想法。在那之后还要经历撰写题面，编写标程，设计部分分，验证数据正确性和强度等一系列步骤才能真正完成一道题目的命制过程。一般而言，为NOI系列赛事命题有数百至上千元的报酬，但这些费用只是一种“辛苦费”。<strong>如果单从功利的角度来说，讲课或者专心学术时更好的选择。他们这么做完全是出自于一种对于OI的情怀</strong>。</p>
<p>但命题质量和数量的保障，甚至保密性都只能由他们自己来保证。如果在NOI附近正好处于出题人们idea的枯竭期，那么NOI的质量势必不高。如果出题人正好要准备大学的期中考试等事情，那么他很难全副身心地去做出题的工作。就算出题人很用心的出了一道题，但是这道题也有可能因为难度不合适等问题而不适合出现在比赛中。也可能是因为这些原因，OI历史上出现过很多设计不合理的比赛。ZJOI2018的难度过高、区分度过低，CTSC2018的题目出错，NOIP2018的原题现象，CTS2019的知识点分布不合理都是鲜活的例子。</p>
<p>改进质量的方法，很大程度上仰仗于OIer与命题人的反馈交流，迫使出题人做出调整。你会在知乎上看到“如何评价xxxx（某比赛）”问题，就是出题人与选手的互动。底下这些评论往往表达选手的做题体验和出题人的出题经历，例如 [1]。最近还出现一些选手在自己出模拟赛的过程中探讨出题的准则，比如 [2] 。 出题人了解某道题的得分情况和选手对这道题的评价后，他才能了解选手的普遍水平，才能了解哪些类型的题是对当下选手最具有考察价值的。在2017年某个出题人出过一道名为《挑战》的题，正解是使用底层优化（卡常）使理论复杂度很高的算法通过匪夷所思的范围（O(n^2)O(n<br>
2<br>
)跑3e5,O(n)O(n)跑2e8）。这场比赛当天该题被批判的声音就层出不穷了。之后这位出题人出的题，质量就有了很大的改观。</p>
<h2 id="学习的过程">学习的过程</h2>
<p>作为一个选手，你最关心的可能是学习OI的过程。在NOIP提高组以下的层面，学习知识点可以通过看书，但是在这以上，尤其是针对较新的知识点的学习，就要依靠网上的博客了。博客一般是由现役的选手来完成的。但博客的质量鱼龙混杂，良莠不齐，你在百度上搜lct，10篇里面有6篇的findroot后没有splay。即使是水平较高的选手，他们写的题解也不一定能让别人容易看懂，很多时候简略到只有一句话。一个普遍的问题是讲解知识点或题目的时候单单着重于结论、算法过程，没有把想到这个结论为什么是正确的、这个算法为什么要想到这两个问题讲清楚。[3] 表达了和我类似的想法。你有时看到题解大呼”太巧妙了”，“太神仙了”，其实是因为没有体会到思考的全过程。为了解决博客质量的问题，我们建立了OI-wiki，shareOI，洛谷的题解拥有严格的审核机制。</p>
<p>洛谷、LOJ、UOJ上的学习资料是免费的，网上的博客是可以直接搜到的，是面对所有OIer的。在这个资源共享化的时代，你只要肯下功夫学，就有丰富的资料和题目可供学习。这一定程度上拉平了强校与弱校的差距。但是由于我上一段提到的原因，学习不能完全依靠于博客等资料，需要有选手来带，需要有优质的模拟题来增加比赛经验。往往只有强校能请的了上一届的优秀选手来讲课，能拥有不对外公开的模拟题和OJ，所以强校与弱校的差距也将长期存在。</p>
<p>另一个重要的方面是讲课，这一工作也由高水平选手承担。讲课一种是在机构受聘讲课，另一种是在自己的母校讲课（这种包括现役选手和退役选手）。前者的特点是受惠面积广，能够让更多人学习。后者的特点是学生较少，容易通过调整自己的讲课方式来满足本校学生的需求。相比于前者，后者带有更多的自愿性。前者推动了OI资源的共享，而后者起到推动一个学校发展的作用。这并不是说前者优于后者或后者优于前者，事实上两者都是必不可少的。特别是对我们学校来说，让上一届去带下一届是向外省强校追赶的必不可少的环节。而一个小集体的发展与一个大集体的发展是相互联系的，有时一个学校的优秀选手可以带动一个省的崛起。</p>
<h2 id="一条从未走过的路">一条从未走过的路</h2>
<p>OI的知识与我们小学中学所学的东西是无关的，甚至与大学所学的算法和主流的计算机科学界关系都不是很大，它是一个相对独立而封闭的体系。我们缺少完全理解OI知识体系的老师，我们缺少能够长期命题的出题人，我们缺少专业的研究者。我们面临了种种不利的客观条件，这些是其它四大竞赛所没有的困难。</p>
<p>但我们不曾放弃，我们不曾退缩。我们竭尽全力探索出一种符合OI竞赛特点的模式。这往大里说，是“计算机普及要从娃娃抓起”的践行；往小里说，是为适应时代做出的努力。</p>
<p>我们终究探索出了一条从未走过的路，那便是<strong>以OIer本身为主导的OI模式</strong>！我们用已经培养出来的OI选手去担任知识引入、命题、授课的工作，用上一届OIer带动下一届OIer，再让下一届带动更下一届。我们借助互联网的平台，发挥它传播信息迅速的优势，把所有的OI选手们连接成一个整体。把而竞赛教练的作用，更多的是去维持这种模式，带动这种模式。</p>
<p>这样的模式是偏向于“用爱发电”的，它的核心基础是<strong>OIer们对OI本身持久的情怀</strong>。它的优点是让OI界具有很强的活力，给选手学习很大的自由度，也对OI的过度商业化，功利化形成了很好的保护。它也使得”OIer群体“这个概念有了很大的地位。</p>
<p>不过也容易想到它是脆弱的、不成熟的，在前面你可以看到它的缺陷。一旦OIer们全都由于一些现实上的原因没有继续服务于OI，必然会使这个体系有崩塌的风险。但它具有很强的<strong>不可替代性</strong>，无论是知识引入还是出题、授课，都只有OIer能胜任。这种模式在现实条件下几乎是唯一的解，所以它是很难撼动的。所以我们应该想的是在<strong>方式方法层面上做一些改进</strong>，让OI的未来变得更好。</p>
<h1 id="oier的价值">OIer的价值</h1>
<h2 id="开拓者">开拓者</h2>
<p>你打开OJ，思考一道题目。你满足于OJ页面的精致，你陶醉于算法世界的美妙。你可曾想过这些题目是谁出出来的，你可曾想过OJ的搭建和维护者是谁？他们是某一个特别的OIer的群体。他们中有洛谷的创办者kkksc03，LOJ的创办者menci和UOJ的创办者vfk。</p>
<p>你可以从 [4]、[5] 和 [6] 中窥探出当年他们创办UOJ、LOJ的一些理念。我们在第一篇文章中截取两段：</p>
<p>&quot;不得不说今天是个伤感的夜晚。我们此时站在这里，连接过去和未来。曾以为我们的计划会成为我们的未来，却不知道大浪拍击沙滩的力量比飓风更有力。UOJ从哪里来？今晚的UOJ还是一年前发布时的那个UOJ吗？为什么我们慢慢忘了那最虔诚的最初，渐行渐远……于是我意识到，我们应该回去，回头看看那最初的原点。最初我是怀着对OI界题目的不满，最初我和业界毒瘤有很多比较难的脑洞想出给大家玩，最初的最初是那场引发我对OI比赛的思考的NOI2013……我们想建立的是，一个能自由评测各种类型题目的OJ，一个题题高质量的OJ，一个定期举办高质量的比赛的OJ —— 一个能带给OIer思考与收获的OJ。&quot;</p>
<p>&quot;我想起了我最初的一句'宁缺毋滥'，我想起了激励了我很长时间的洛克菲勒与协和医院的故事：我们要以最高标准建一所医院，成为中国医学界的一座标杆 —— 而我们清楚地知道，论题目的数量，世界上千万万OJ不缺我们UOJ一家，我们要做的就是聚集最优秀最热爱信息学的OIer，建立一个题目质量难以企及的OJ。&quot;</p>
<p>500多道UOJ题目，上千道LOJ题目，数万个OIer......今天你会看到各个学校的OJ如雨后春笋般增长，就归功于他们用一行行代码缔造的平台。今天你会听到OIer对比赛、对题目的广泛讨论，而那些新潮的想法其实来源于vfk在那几篇博客上阐述的”好题“、“毒瘤题”的定义。今天我们从自己的成长之路向前追朔，也总能够追朔到他们的所创造的资源。</p>
<p>他们是灯塔，他们是引路人。他们开拓了一条OI资源共享化的道路，他们以数十人之力创造了数万人的价值。在之后的社会上，你很难看到像他们一样完全坚持自己的初心、梦想，无私地奉献自己的一切而不求任何回报的人了。我们希望他们的那些文字能够在OI的历史上熠熠生辉。</p>
<h2 id="不可或缺的角色">不可或缺的角色</h2>
<p>诚然，我们很难像他们一样对整个OI界做出很大的贡献，对他们的态度也只是停留在“虽不能至，心向往之”的层面。那么我们的价值又在何处呢？</p>
<p>很多学校的教练都会在我们还是初三或高一时请高二的学长给我们来讲课。一年过后，我们欢送他们退役，但我们站在他们的肩膀上，经过各种比赛的磨练，使自己变得更强。当我们磨练得差不多时候，我们就成了学长，就被要求给下一届的学弟学妹们讲课。WC2018的两首改编歌词《我的一个OIer朋友》，《退役的你》（详见 [7] 、 [8] ）是这段时光的真实写照。我们从第一首里面截取一段：</p>
<blockquote>
<p>&quot;他们说的退役太沉重，你在路上追着你的梦。<br>
前路会与过往不同，但精彩纷呈。<br>
而我深夜刷题至三更，大赛过后睡眼正惺忪。<br>
恍然之间终于看懂，当年你笑容，谈何轻松？<br>
不如将你镌刻在心中，以足迹为路以背影为灯。<br>
去年今日你的歌声，由我来传承......”</p>
</blockquote>
<p>在这一段OI的旅途中，我们送走了一批人，又迎接了新的一批人。 我们把从学长那里得到的东西，经过自己的再加工、再整理，传递给下一届，然后由知识的接受者变为了知识的传播者。我们成了手握接力棒的人，成了连接过去和未来的人。这段旅途中难免有送别的伤感，但薪火相传的使命与责任，才是主旋律。</p>
<p>如果我们中出现了一个优秀选手，那么就会产生更大的贡献。一是会吸引更多的OIer来这所学校学习，然后进一步提高下一届选手的水平。比如我在初三时选择进入华二而非上中，是因为看到2017年华二CMO进了5个集训队，而上中只进了一个。二是会使整个省的目标提高，进而带动整个省的水平。在2016年前，可能上海的目标是争取更多银牌选手。但因为像吕时清、何文阳之类的优秀选手出现，特派员开始朝着金牌这个目标努力了。他会亲自那些不错的OIer下发题目，亲自评测、会在NOIP/CSP前安排几次针对全市选手的模拟赛，会请外省的集训队选手来讲课。最终上海在CTS，APIO，NOI上实现了这一目标。</p>
<p>哪怕你只是初二、初三、高一的OIer，还没有达到给学弟学妹讲课的阶段，你也会不知不觉中影响很多人。在这个资源高度共享的时代，你不经意间说的话，写的东西就可能会被数百人看到，然后数百人传给更多人。就像我博客里面写的“JOISC 2020自闭记”，阅读量已经达到了530人，而我认识的OIer也不过100人。也许这530人还会传给他们的朋友、他们的下一届选手，说不定就有1000人直接或间接地看到了我写的题解了。</p>
<h2 id="另一种价值">另一种价值</h2>
<p>由于OI竞赛本身这种独特的模式，OIer群体的概念与个体的概念，拥有同等的地位。所以一个OIer在他的生涯中，不仅存在个人价值（比如拿一等奖，进省队，进集训队），还存在着另一种价值，那便是个人对OIer群体的价值。</p>
<p>很多时候实现个人价值也是实现这种价值，这种价值是个人价值的延续，因为高水平选手给OI界可能创造的价值越多。但和个人价值不同的是，这种价值所影响的时间更长，所影响的范围更广。也许我们退役过后，我们所获得的奖项，只是OIerdb上那一条条数字了。<strong>个人价值是一个OIer退役后所带走的，但这种价值是一个OIer退役后留下的东西</strong>，它是不会过时的。你为你身边的OIer所做的事情，像是埋下一粒种子，它会在几年之内生根、发芽，长成一棵大树，甚至繁殖出更多的生命。vfk那一代的OIer很难想到他所创办的UOJ能使这么多人受益，王聿中、吕时清、王润泽那一代的OIer也没有想到他们的努力会使上海在NOI2019进入3个集训队。但这一切，都在不久的将来发生了。</p>
<p>所以我们在学习知识之余，也要想一想我能为我身边的OIer做些什么，我能为整个学校做些什么，我能为整个市做些什么，我能为整个OIer做些什么？知识层面上的贡献有：出题、讲课、写论文等。另一种贡献是文、史、哲层面上的，比如Tangenter写《整型溢出》一书整理2016-2019年的OI历史。即使我们还没有达到为别的OIer做事情的阶段，我们也要了解别人给OI界带来的贡献，我们也要对那些为我们付出过的前辈们怀以感激，怀以敬意。</p>
<h1 id="渺小而卑微的坚持">渺小而卑微的坚持</h1>
<p>时间、运气、命运对OIer们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的OIer，也难以保证他在省选或NOI一定能够有和他的付出对等的回报。这是很多OIer心知肚明的事实，也是我们无力感的根源。</p>
<p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p>
<p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打cf，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100分与0分之差，一个部分分之差就可能是20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p>
<p>OIer之外的人对他们有两种极端的态度。一种是以竞赛的风险为理由，劝说（甚至逼迫）他们放弃OI竞赛而去搞高考。这些人否认OI给他们带来的意义，没有看到他们在OI方面的付出。也许从数学期望的角度，这是较优解，我们不必做过多的批判。但这种态度杀灭了他们的纯粹的梦想，给他们的青春留下无法抹去的遗憾，甚至伤痕。另一种是盲目地支持，为了走这条路而断绝他们的一切后路，放弃一切OI之外的事务。人不是机器，过度的、长时间的投入是否会产生和这种投入成正比的收获，是不好说的。即使成功了，它能否补偿他们所失去的东西，也是不好说的。这种态度产生的根源是没有客观地认识到OI的风险，把竞赛和高考的两套评价体系完全地割裂开来，甚至当成对立面。</p>
<p>我们应有的态度是怎样的呢？应该是一个朋友的角色。我们可以在他们考砸的时候予以安慰，可以在他们考好的时候予以鼓励。我们可以和他们一起讨论题目，一起学习算法，一起打模拟赛，甚至在空闲时刻聊一些游戏、漫画的内容。我们既要提供助力他们成功的实质性帮助，也要想方设法缓解他们的压力感和孤独感。当然，我个人认为，不必对他们的选择做过多的干预，因为我们很难完全理解他们的内心想法，很难影响也不应去影响他们的命运。至于决定他们是选择坚持还是放弃，应该是老师和家长所做的事情。</p>
<p>如果你觉得他们离你很遥远，<strong>请你不要像某些人一样用好坏利弊简单地评判他们的选择，请你不要抱着“与我无关”的态度</strong>。</p>
<p><strong>如果你正好就是那些选择孤注一掷的OIer，请你相信有无数的OIer是支持你的，请你相信你的付出终将会在某个时刻回报你，请你相信无论怎样，你在这个过程中成长了、收获了。但也要告诉你，既然有勇气坚持走下去，也要有勇气承担它带来的一切结果。</strong></p>
<h1 id="后记">后记</h1>
<p>其实我写这篇博客的想法，可以追溯到北大集训期间LCA给我们讲的一些话。在他的讲话过后，我了解到了OI diary，我了解到了OI survey。我看到了有一位前OIer去主动地查找资料，以一个选手的视角记录前几年OI界发生的事情，甚至有一个人想编撰一部完整的OI史。我发现OIer们做了很多学习知识之外的事情，例如对自身价值的探索，对学习竞赛的意义、乃至生命的意义的探讨。这种东西既体现在某一小群OIer所写的长篇的文章里面，又渗透到了很多OIer博客里的随感。于是我也对OI界的一些现状做了简单的思考，整理成了这篇博客。</p>
<p>如果从写文章的角度来说，第一、第二节可以构成一个完整的主题，而第三节显得有点画蛇添足。但是在我身边真的有很多选择孤注一掷地搞OI的人，其实在我的学校里就有，而他们面临的环境并不乐观。我特别想为他们说一些话，却不知道何时能说，却不知道从何说起。所以我就在这个机会为他们说出我的心里话。</p>
<p>最后，感谢你能够读完这篇博客，也希望这份思想的火炬永不熄灭！</p>
<p>链接： <a href="https://www.zhihu.com/question/333860946/answer/755528534">1</a></p>
<p><a href="https://www.luogu.com.cn/blog/ouuan/to-be-a-good-problemsetter">2</a></p>
<p><a href="https://etaoinwu.com/blog/on-teaching-and-learning/">3</a></p>
<p><a href="http://vfleaking.blog.uoj.ac/blog/909">4</a></p>
<p><a href="http://vfleaking.blog.uoj.ac/blog/4">5</a></p>
<p><a href="https://loj.ac/article/45">6</a></p>
<p><a href="https://www.bilibili.com/video/BV1KW411E7gu?p=1">7</a></p>
<p><a href="https://www.bilibili.com/video/BV1HW411n7vQ?p=1">8</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅析 Dijkstra 算法（堆优化）]]></title>
        <id>https://lewis-li-lyf.github.io/post/Dijkstra/</id>
        <link href="https://lewis-li-lyf.github.io/post/Dijkstra/">
        </link>
        <updated>2020-04-14T13:41:43.000Z</updated>
        <content type="html"><![CDATA[<p>最短路问题是图论中的一个很经典的问题。它分为单源最短路径和多源最短路径两大类。具体内容请自行 BFS。Dijkstra就是一个用来解决单源最短路径问题的很经典的算法。<br>
首先，我们要记住一句话：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle mathsize="2.074em"><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi><mi>S</mi><mi>P</mi><mi>F</mi><mi>A</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">死</mi><mi mathvariant="normal">了</mi></mstyle></mrow><annotation encoding="application/x-tex">\huge 关于SPFA：它死了
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.41722642em;vertical-align:0em;"></span><span class="mord cjk_fallback sizing reset-size6 size10">关</span><span class="mord cjk_fallback sizing reset-size6 size10">于</span><span class="mord mathdefault sizing reset-size6 size10" style="margin-right:0.05764em;">S</span><span class="mord mathdefault sizing reset-size6 size10" style="margin-right:0.13889em;">P</span><span class="mord mathdefault sizing reset-size6 size10" style="margin-right:0.13889em;">F</span><span class="mord mathdefault sizing reset-size6 size10">A</span><span class="mord cjk_fallback sizing reset-size6 size10">：</span><span class="mord cjk_fallback sizing reset-size6 size10">它</span><span class="mord cjk_fallback sizing reset-size6 size10">死</span><span class="mord cjk_fallback sizing reset-size6 size10">了</span></span></span></span></span></p>
<h1 id="dijkstra-思路解析">Dijkstra 思路解析</h1>
<p>Dijkstra 采用的是 <strong>贪心</strong> 的思想。<br>
我们定义一个<code>dis</code>数组，<code>dis[i]</code>表示起点<code>s</code>到节点<code>i</code>的最短距离。<br>
每一次我们从所有未被标记过的点中找到<code>dis[i]</code>最小的那个点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，将其标记上。之后枚举其所有的出边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>&gt;</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">dis[y] &gt; dis[x] + z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>，那么就用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">dis[x]+z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>来替代<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dis[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>。<br>
但是，也正是因为这种贪心的思想，Dijkstra 无法处理有负边权的问题。</p>
<ol>
<li>初始化<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dis[1]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其余为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>inf</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span></span></span></span>（正无穷）</li>
<li>找出一个未被标记的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dis[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>最小的点，标记为点<code>x</code>。</li>
<li>将点 x 的出边扫一遍，并进行松弛</li>
<li>重复2，3直到所有点都标记完毕。</li>
</ol>
<pre><code class="language-cpp">//不知为何，这份代码是错的，看看就行了
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 10010;
const int maxm = 500010;
const int inf = 2147483647;
int dis[maxn];
bool vis[maxn];
int n, m, s;
int head[maxn], cnt;
struct Edge
{
    int to, next;
    int weight;
} e[maxm];
void addedge(int from, int t, int w)
{
    e[++cnt].to = t;
    e[cnt].weight = w;
    e[cnt].next = head[from];
    head[from] = cnt;
}
void dijkstra(int s)
{
    for (int i = 1; i &lt;= n; i++)
    {
        dis[i] = inf;
        vis[i] = 0;
    }
    dis[s] = 1;
    for (int i = 1; i &lt; n; i++)
    {
        int x = 0;
        for (int j = 1; j &lt;= n; j++)
        {
            if (!vis[j] &amp;&amp; (dis[j] &lt; dis[x] || dis[x] == 0))
                x = j;
        }
        vis[x] = 1;
        for (int j = head[x]; j; j = e[j].next)
        {
            int w = e[j].weight;
            dis[j] = min(dis[j], dis[x] + w);
        }
    }
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;
    for (int i = 1; i &lt;= m; i++)
    {
        int f, t, w;
        cin &gt;&gt; f &gt;&gt; t &gt;&gt; w;
        addedge(f, t, w);
    }
    dijkstra(s);
    for (int i = 1; i &lt;= n; i++)
        cout &lt;&lt; dis[i] &lt;&lt; ' ';
}
</code></pre>
<h1 id="堆优化">堆优化</h1>
<blockquote>
<p><strong>这年头哪个人写 Dij 不加堆优化</strong>——大奆@<a href="https://www.luogu.com.cn/user/244204">欧阳达晟</a><img src="https://cdn.luogu.com.cn/upload/image_hosting/x5gvzsbs.png" alt="" loading="lazy"></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[广度优先搜索BFS]]></title>
        <id>https://lewis-li-lyf.github.io/post/BFS/</id>
        <link href="https://lewis-li-lyf.github.io/post/BFS/">
        </link>
        <updated>2020-04-12T10:08:23.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://bkimg.cdn.bcebos.com/pic/adaf2edda3cc7cd9d2011b873901213fb80e91bb?x-bce-process=image/resize,m_lfit,w_268,limit_1" alt="自然界的广搜" loading="lazy"></figure>
<h1 id="广搜介绍">广搜介绍</h1>
<p>很久很久以前，我们万能的度娘曾经说过：</p>
<blockquote>
<p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p>
</blockquote>
<p>这里以树上BFS为例：（图片来源于网络）<br>
<img src="https://images2015.cnblogs.com/blog/702268/201510/702268-20151017224747976-1823570842.png" alt="一棵树" loading="lazy"><br>
直观上来说，就是<strong>一层一层的搜索</strong>。并且，在搜索完第k层节点之前，是<strong>绝对不会</strong>搜索第k+1层的。</p>
<h1 id="适用范围">适用范围</h1>
<p>一般来说，BFS适用于那些<strong>边权相等</strong>的图。一个很好的例子便是地图：当你BFS死第一次碰到目标点，则此时你走过的路径一定就是起点到目标点的<strong>最短距离</strong>（BFS最短路）。因为你是一层一层搜的，就相当于是一步一步走的，既然先遇到目标点，那么就一定是最短的。<br>
对于有边权的图，我们就可以使用那些更高级的最短路算法（比如 <em>Dijkstra</em> ）（Floyd：我不要面子的嘛ヽ(#`Д´)ﾉ）</p>
<ul>
<li>BFS求无权图最短路径问题</li>
<li>BFS染色判断是否为二分图</li>
<li>寻找图中一个连通分支的所有节点</li>
</ul>
<h1 id="代码实现">代码实现</h1>
<p>首先，我们从起始节点<code>root</code>开始，压入队中。随后，将其所有连接着的点都压入队中。弹出队首。之后再将队首的节点压入队中并按照出队顺序遍历第二层。完成之后，队内剩下的就是第三层的节点。重复上述过程，直到没有节点为止（队空）。</p>
<pre><code class="language-cpp">struct Edge // 链式前向星大法好
{
    int to, next;
} E[1010]; 
int head[110], cnt; 
void addEdge(int u, int v) // 增加一条边
{
    E[cnt].to = v;
    E[cnt].next = head[u];
    head[u] = cnt++;
}
bool vis[110];     // 记录已经走过的点，防止重复访问。
void BFS(int root) // BFS
{
    queue&lt;int&gt; q;
    memset(vis, 0, sizeof(vis)); // 初始化。
    vis[root] = 1;
    q.push(root);
    int u, len;
    while (!q.empty())
    {
        u = q.front();
        q.pop();
        len = E[u].size();
        for (int i = head[root]; i; i = E[i].next)
        {
            int v = E[i].to;
            if (vis[v] == 0)
            {
                vis[v] = 1;
                q.push(v);
            }
        } // 找到和u相连的所有点并入队
    }
}
</code></pre>
<p>这样就做到了遍历整个图。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[致敬：向那些为抗击疫情而牺牲的烈士]]></title>
        <id>https://lewis-li-lyf.github.io/post/COVID-19/</id>
        <link href="https://lewis-li-lyf.github.io/post/COVID-19/">
        </link>
        <updated>2020-04-04T01:48:20.000Z</updated>
        <content type="html"><![CDATA[<p>我相信，这个冬天给了我们太多。可能是悲伤的记忆，可能是告别亲人的不舍，可能是千千万万前线战士带给我们的感动，也可能是坚定抗争中生命的顽强与不屈。</p>
<p>一个个逝去的生命，他们带着我们的目光，他们带着千千万万人民的悲伤，轻轻的离开了我们。在白衣战士面前，在全国十三亿人民面前，在全世界七十亿的朋友面前，他们没有多言，带着一个无怨无艾的笑，离开。</p>
<p>但是，我们不会被轻易击垮。严冬过后，便是温暖的阳光，便是蓬勃的春草，便是绚烂的夏花。</p>
<p>清明，在阴雨绵绵间，来了。</p>
<p>我们总可以说，这个刚刚过去的冬天，是分外漫长的。他太沉重了，这样一个寒冬不足以承受这样的重量——这是亲人的离别，这是生命的消逝，这也是一个民族的哀伤。</p>
<p>我们见证了太多，我们也面对了太多，但是，在今天，我们无需多言，真正值得我们做的，是认真的想想我们得到的一切，和逝者失去的一切。</p>
<p>愿，所有的人都可以得到属于自己的完满，所有的告别都不再悲伤。</p>
<p>也许单薄的语言无法慰藉任何的悲伤，但是，我总是还是希望，在博客的一篇文章，在讨论的一段话，总可以让悲伤的人多一丝温暖的希望。</p>
<blockquote>
<p>燃一缕思念的烛火，愿逝者安息；带着思念前行，愿生者坚强。</p>
</blockquote>
<p>默哀。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[转载：CSP]]></title>
        <id>https://lewis-li-lyf.github.io/post/zhuan-zai-csp/</id>
        <link href="https://lewis-li-lyf.github.io/post/zhuan-zai-csp/">
        </link>
        <updated>2020-04-02T14:49:58.000Z</updated>
        <content type="html"><![CDATA[<p>盼望着，盼望着，模拟赛来了，CSP的脚步近了。</p>
<p>一切都像刚WA的样子，欣欣然重构代码。代码复杂度朗润起来了，时间复杂度涨起来了，CE的标志红起来了。</p>
<p>毒瘤数据偷偷地从土里钻出来，嫩嫩的，绿绿的。洛谷里，CODE FORCE里，瞧去，一大片一大片满是的。坐着，躺着，写两个for，码几脚while，跑几趟dfs，搜几回暴力。TLE轻悄悄的，MLE软绵绵的。</p>
<p>POJ、HDU、51nod，你不让我，我不让你，都开满了WA赶趟儿。红的像火，粉的像霞，白的像雪。WA里带着RE；闭了眼，评测界面仿佛已经满是UKE、ERR、OLE。花下成千成百的蜜蜂嗡嗡地闹着，大小的蝴蝶飞来飞去。0分遍地是：杂样儿，DP没初始化的，数学公式写错的，散在评测机里，像眼睛，像星星，还眨呀眨的。</p>
<p>“吹面不寒AK风”，不错的，像CCF主席的手抚摸着你。风里带来些新翻的AC的气息，混着打表味儿，还有各种骗分的香，都在微微润湿的AK里酝酿。模拟将巢安在长篇文章当中，高兴起来了，呼朋引伴地卖弄超过200行的代码，唱出宛转的AC音乐，与轻风流水应和着。IOI通过的短笛，这时候也成天嘹亮地响着。</p>
<p>Debug是最寻常的，一调就是三两天。可别恼。看，像无限循环，像scanf不写&amp;，像数组越界，密密地斜织着，人家exe上全笼着一层01串。大佬的评测却AC得发亮，蒟蒻的评测也青蛙得逼你的眼。傍晚时候，上灯了，一点点算法错误的光，烘托出一片贪心错误的夜。在乡下，小路上，石桥边，有撑起伞慢慢走了1e18秒的人。还有地里工作的码农，披着电源戴着黑帽子的。他们的电脑，稀稀疏疏的在调试里静默着。</p>
<p>天上AKNOI渐渐多了，地上AKIOI也多了。俄国中国，克罗地亚，波罗的海，也赶趟儿似的，一个个都出来了。AKAK CSPJ，AKAK CSPS，各AK各的一份事去。“一年之计在于CSP”，刚起头儿，有的是爆零，有的是RE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构：堆]]></title>
        <id>https://lewis-li-lyf.github.io/post/heap/</id>
        <link href="https://lewis-li-lyf.github.io/post/heap/">
        </link>
        <updated>2020-04-02T04:05:58.000Z</updated>
        <content type="html"><![CDATA[<p>在众多数据结构中，有一种数据结构很强大。它的时间复杂度很小，使他能够高效地进行运算。它就是——堆。</p>
<p>本文资料来源于《信息学奥赛一本通》和百度百科。</p>
<h1 id="堆是什么">堆是什么</h1>
<p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：</p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<p>堆的定义如下：n个元素的序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>k</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{k_1,k_2,k_i,…,k_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>当且仅当满足下关系时，称之为堆。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>k</mi><mi>i</mi></msub><mo>⩽</mo><msub><mi>k</mi><mrow><mn>2</mn><mo>⋅</mo><mi>i</mi></mrow></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>⩽</mo><msub><mi>k</mi><mrow><mn>2</mn><mo>⋅</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(k_i \leqslant k_{2 \cdot i},k_i \leqslant k_{2 \cdot i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩽</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>k</mi><mi>i</mi></msub><mo>⩾</mo><msub><mi>k</mi><mrow><mn>2</mn><mo>⋅</mo><mi>i</mi></mrow></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>⩾</mo><msub><mi>k</mi><mrow><mn>2</mn><mo>⋅</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(k_i \geqslant k_{2 \cdot i},k_i \geqslant k_{2 \cdot i+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⩾</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">⋅</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4...</mn><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">(i = 1,2,3,4... \dfrac{n}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<p>前者我们称作小根堆（小顶堆），后者我们称作大根堆（大顶堆）。</p>
<h1 id="堆支持的操作">堆支持的操作</h1>
<p>堆都支持什么操作呢？</p>
<ol>
<li><code>Push</code>向堆中插入一个元素</li>
<li><code>Pop</code>删除并返回堆中的一个元素（根节点）</li>
<li>堆排序</li>
</ol>
<p>要构建一个二叉堆，我们只需要进行若干次插入操作即可。<br>
在进行操作之前，我们要先定义一个<code>size</code>，表示当前堆的节点个数。<br>
下面以小根堆为例。</p>
<h1 id="插入操作">插入操作</h1>
<p>我们把要插入的数<code>tmp</code>插入到堆尾，再通过若干次调整使得它满足堆的性质。如果它比它的父节点小，则交换两个节点，一直到不可交换为止。<br>
<img src="https://i.loli.net/2020/04/02/5SzNq8nK7614Lkm.png" alt="not-named.png" loading="lazy"><br>
现在，我们要向堆中插入一个<code>1</code>：<br>
先将1插入到堆尾，随后把它与它的父亲6做对比，交换这两个数。随后再将1和4进行对比，再交换。现在，它的父亲是1，不需要再上浮了。至此，我们的插入操作就完成了。因为在插入之前，上面的永远比下面小，所以不会出现交换之后不满足性质的情况。</p>
<pre><code class="language-cpp">void push(int d){//小根堆 
    int now,next;
    heap[++siz] = d;//siz表示堆的大小，即二叉树的节点个数
    now = siz;//现在的节点
    while(now &gt; 1){
        next = now &gt;&gt; 1;//父节点
        if(heap[now] &gt;= heap[next])//满足堆的性质，直接返回
            return ;
        swap(heap[now],heap[next]);//不满足性质，交换
        now = next;//“代代相传”
    }
}
</code></pre>
<h1 id="删除操作">删除操作</h1>
<p>我们的删除操作会按以下步骤进行：</p>
<ol>
<li>取出堆的根节点的值</li>
<li>把这个堆的最后一个节点放在根节点的地方来覆盖根节点，同时将size-1。</li>
<li>将根节点设置为当前父节点。</li>
<li>如果无儿子，则直接return。否则选出这个父节点的两个儿子中<strong>较大/小的那个</strong>，与父节点比较。不满足堆的性质就交换。</li>
<li>重复执行3，4。</li>
</ol>
<p>这样，我们就成功删除并返回了堆顶的元素。</p>
<pre><code class="language-cpp">void pop(){
    int now,next,res;//见上
    res = heap[siz];
    heap[1] = heap[siz--];//覆盖根
    now = 1;
    while(now&lt;&lt;1 &lt;= siz){
        next = now &lt;&lt; 1;
        if(next &lt; siz &amp;&amp; heap[next+1] &lt; heap[next])//开始比较
            next++;
        if(heap[now] &lt;= heap[next])
            return ;
        swap(heap[now],heap[next]);//交换
        now = next;//“子继父业”
    }
    return res;
}
</code></pre>
<p>至此，我们的手写小根堆就完成了。</p>
<p>#STL版本（priority queue优先队列版本）<br>
为什么不用STL自带的heap？因为写起来太麻烦了。<br>
首先，我们需要一个头文件<code>#include&lt;queue&gt;</code><br>
之后，我们来定义：</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
priority_queue&lt;int&gt;q;//这是一个大根堆
priority_queue&lt;int,vectot&lt;int&gt;,greater&lt;int&gt; &gt;q;//这是小根堆，注意这里后面要有空格 ，以免编译器看成运算符&gt;&gt;
</code></pre>
<p>它支持的操作有：</p>
<pre><code class="language-cpp">q.top()//取得堆顶元素，并不会弹出
q.pop()//弹出堆顶元素
q.push()//往堆里面插入一个元素
q.empty()//查询堆是否为空，为空则返回1否则返回0
q.size()//查询堆内元素数量
</code></pre>
<p>综合来看，STL版本的堆完爆手写堆，毕竟难度差距不是一般的大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Trie 树]]></title>
        <id>https://lewis-li-lyf.github.io/post/Trie/</id>
        <link href="https://lewis-li-lyf.github.io/post/Trie/">
        </link>
        <updated>2020-03-27T06:09:12.000Z</updated>
        <content type="html"><![CDATA[<p>好久没写博客了呢~</p>
<p>所以，<br>
我这个蒟蒻终于啃掉了AC自动机——</p>
<p>但我要讲的是</p>
<h1 id="trie-树">Trie 树</h1>
<p><s>踹树</s><br>
那么 <s>踹树</s> Trie 树是什么？</p>
<blockquote>
<p><em>字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</em> —— <em>某度某科</em><br>
<em>在计算机科学中，Trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。  —— 维基百科</em></p>
</blockquote>
<p><s>从上面可以看出，Trie 树是用来做字符串查找题的</s></p>
<p>Trie 树是一种典型的<br>
<strong>用空间换时间的算法</strong><br>
它快，是因为单词之间拥有<strong>公共前缀</strong>。</p>
<p>来看一张我画的图：<br>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/8xrb9nip.png" alt="" loading="lazy"></p>
<p>从根节点开始，每个节点都最多 有26个分支，也就是说，Trie 树是一个26叉树。<br>
那么图中有几个单词呢？ ——4个，分别是ab,b,zc,zd。<br>
标红点代表有一个单词。</p>
<h1 id="怎样插入单词呢">怎样插入单词呢？</h1>
<p>我们要插入一个单词，需要逐位分析。</p>
<p>比如插入单词 bc。<br>
从根节点出发，发现当前有第一个字母b，继续找<br>
第二个字母 c，发现当前没有 c，于是新建一条。<br>
因为这是单词末尾，所以打上标记 =&gt; 红色。</p>
<p>于是，我们就可以踹树了（手动滑稽）</p>
<p>建立：</p>
<pre><code class="language-cpp">struct node{
	int ch[26];
	bool have;
}t[800000];
</code></pre>
<p>插入</p>
<pre><code class="language-cpp">int num = 0;
void insert(string s){
	int u=0,len=s.size();
	for(int i=0;i&lt;len;i++){
		int v=s[i]-'a';//统一大小写
		if(!t[u].ch[v]){
			t[u].ch[v]=++num;
		}
		u=t[u].ch[v];
	}
	t[u].have=true;//打标记
	return ;
}
</code></pre>
<h1 id="查询">查询</h1>
<p>再放一下图</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/8xrb9nip.png" alt="" loading="lazy"></figure>
<p>假如我们现在要查 zc 这个单词。<br>
从根出发，有节点 z，那么顺着这条向下走。<br>
有节点 c 。因为 c 是最后一位，所以查看这里的标记——有标记。说明有 zc 这个单词。<br>
而查询 bc 的时候，b 下面没有 c，所以没有 bc 。</p>
<pre><code class="language-cpp">int query(string s){
	int u=0,len=s.size();
	for(int i=0;i&lt;len;i++){
		int v=s[i]-'a';
		if(!t[u].ch[v]) return false;//没有单词，直接返回false
		u=t[u].ch[v];
	}
	return t[u].have;//如果有标记，返回true，否则false；
}
</code></pre>
<p><s>踹树真好</s></p>
<p>Trie 树在字符串方面运用的很广泛，一般来说，主要运用于字符串的储存。AC自动机就是使用 Trie 树来储存的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[转载：自由的召唤]]></title>
        <id>https://lewis-li-lyf.github.io/post/The-Call-of-Freedom/</id>
        <link href="https://lewis-li-lyf.github.io/post/The-Call-of-Freedom/">
        </link>
        <updated>2020-03-24T14:06:56.000Z</updated>
        <content type="html"><![CDATA[<p>镜头前，一个男人在舞蹈着。</p>
<p>他身上并没有多少衣物，一个红色头巾，一个遮住关键部位的短裤。</p>
<p>他舞蹈着。</p>
<p>但是仔细看，会觉得这个舞蹈缺少了什么。</p>
<p>是什么呢？</p>
<p>他的动作……似乎有些拘束。</p>
<p>但这也能理解。毕竟，一个男人衣着寸缕，在镜头前……</p>
<p>但这样的舞蹈是没有灵魂的。</p>
<p>他似乎也意识到了这个问题，尽力地想要克服这种拘束。</p>
<p>却总是差那么一步。</p>
<p>我到底在干什么啊？他很迷茫。</p>
<p>突然，一个低头的动作，让他愣住了。</p>
<p>短裤上，印着美利坚的国旗。</p>
<p>他不禁想到了自己的初衷。</p>
<p>他的初衷……</p>
<p>那天，他走在街上。</p>
<p>他看着来往的人们，</p>
<p>有些压抑。</p>
<p>这些人们，都是面无表情，行色匆匆。</p>
<p>他们被拘束了。</p>
<p>他们缺少自由。</p>
<p>于是，他决定，</p>
<p>要改变这个世界，</p>
<p>让这个世界，这些人们，</p>
<p>拥有自由。</p>
<p>他要让美利坚，</p>
<p>拥有自由！</p>
<p>他深呼吸，</p>
<p>身体内的一个闸门似乎被打开了。</p>
<p>他的动作，变得更加有力量。</p>
<p>他的表情，更加放荡不羁。</p>
<p>他的一举一动，都充分地诠释了——</p>
<p>自由。</p>
<p>他要通过自己的舞蹈，</p>
<p>向人们，</p>
<p>向美利坚，</p>
<p>乃至整个世界，</p>
<p>展示着自由，</p>
<p>证明着自由，</p>
<p>诠释着自由。</p>
<p>无论有多少人能理解他的舞蹈，</p>
<p>他都不在乎。</p>
<p>因为，这就是自由！</p>
<p>自由，是没有边界的。</p>
<p>是没有限制的。</p>
<p>更没有人们的世俗眼光。</p>
<p>一段舞蹈结束，</p>
<p>他的脸上带着微笑。</p>
<p>因为，他做到了</p>
<p>他成功了。</p>
<p>他不知道他的舞蹈会给别人带来什么影响，</p>
<p>他只知道，</p>
<p>他享受的仅仅是这个过程。</p>
<p>这个传递自由的过程。</p>
<p>他来自美利坚。</p>
<p>他是那个象征着自由的男人。</p>
<p>香蕉君。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路：Floyd算法]]></title>
        <id>https://lewis-li-lyf.github.io/post/Floyd/</id>
        <link href="https://lewis-li-lyf.github.io/post/Floyd/">
        </link>
        <updated>2020-03-23T07:45:45.000Z</updated>
        <content type="html"><![CDATA[<p>在某位奆佬的指导下，我开始啃图论。<br>
所以我来写一下 <code>Floyd</code> 算法。</p>
<h1 id="什么是-floyd">什么是 Floyd ?</h1>
<blockquote>
<p><em>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。 ——某度某科</em></p>
</blockquote>
<p><s>跟没说一样</s></p>
<p>Floyd 是一种用于解决多源最短路径的题，使用的是动态规划的思想。它的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h1 id="floyd-的思想及怎样写">Floyd 的思想及怎样写</h1>
<p>还是看个图：</p>
<figure data-type="image" tabindex="1"><img src="data:image/png;base64,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" alt="" loading="lazy"></figure>
<p>Floyd 算法会在图中取一个中间点，然后枚举起点和终点，如果从起点到中间点再到终点的权值 大于 从起点直接去到终点的权值，那么就用前者去替换后者。<br>
我们令 <code>dis[ i ][ j ]</code> 表示 <code>i</code> 到 <code>j</code> 的最短路径。<br>
首先将dis全部赋值为极大值，然后输入距离。<br>
之后3个<code>for</code>循环：</p>
<pre><code class="language-cpp">for(int k=1;k&lt;=n;k++){//枚举中间点
   	for(int i=1;i&lt;=n;i++){//起点
   		for(int j=1;j&lt;=n;j++){//终点
   			if(dis[i][j] &gt; dis[i][k] + dis[k][j]){//替换距离
   				dis[i][j] = dis[i][k] + dis[k][j];
   			}
   		}
   	}
   }
</code></pre>
<p>比如图中4-1-3 的 8 大于 4-3 的15，就用 8 去替换15。<br>
<strong>注意：k 的那一层（枚举中间点）必须放在最外面。</strong><br>
循环结束后，<code>dis[ i ][ j ]</code> 即为<code>x</code>到<code>y</code>的最短路径，算法结束。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈ST表]]></title>
        <id>https://lewis-li-lyf.github.io/post/RMQ-ST/</id>
        <link href="https://lewis-li-lyf.github.io/post/RMQ-ST/">
        </link>
        <updated>2020-03-23T07:42:52.000Z</updated>
        <content type="html"><![CDATA[<p>ST表类似树状数组，线段树这两种算法，是一种用于解决RMQ(Range Minimum/Maximum Query,即区间最值查询)问题的离线算法<br>
与线段树相比，预处理复杂度同为O(nlogn),查询时间上，ST表为O(1),线段树为O(logn)<br>
说白了，就是静态的求区间最大值。</p>
<p>st表的主体是一个二维数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">st[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>，表示起始点为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>j</mi></msup></mrow><annotation encoding="application/x-tex">2^j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span>的一段的最值，本文以最大值为例。<br>
ST表使用的是倍增的思想。</p>
<p>已知的是每一个以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为起始，长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup></mrow><annotation encoding="application/x-tex">2^0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span>的区间最值为这个数本身，由此可以推出以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为起始，长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">2^1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span>的最值是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">st[i][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">st[i+1][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的最值。<br>
以此类推。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="monospace">s</mi><mi mathvariant="monospace">t</mi><mo>[</mo><mi mathvariant="monospace">i</mi><mo>]</mo><mo>[</mo><mi mathvariant="monospace">j</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mrow><mi mathvariant="monospace">s</mi><mi mathvariant="monospace">t</mi><mo>[</mo><mi mathvariant="monospace">i</mi><mo>]</mo><mo>[</mo><mi mathvariant="monospace">j</mi><mo>−</mo><mn mathvariant="monospace">1</mn><mo>]</mo><mo separator="true">,</mo><mrow><mi mathvariant="monospace">s</mi><mi mathvariant="monospace">t</mi><mo>[</mo><mi mathvariant="monospace">i</mi><mo>+</mo><msup><mn mathvariant="monospace">2</mn><mrow><mi mathvariant="monospace">j</mi><mo>−</mo><mn mathvariant="monospace">1</mn></mrow></msup><mo>]</mo><mo>[</mo><mi mathvariant="monospace">j</mi><mo>−</mo><mn mathvariant="monospace">1</mn><mo>]</mo><mo>)</mo></mrow></mrow></mrow><annotation encoding="application/x-tex">\tt st[i][j] = \max(\tt st[i][j-1],\tt st[i+2^{j-1}][j-1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040777em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathtt">s</span><span class="mord mathtt">t</span><span class="mopen">[</span><span class="mord mathtt">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathtt">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord"><span class="mord mathtt">s</span><span class="mord mathtt">t</span><span class="mopen">[</span><span class="mord mathtt">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathtt">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathtt">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathtt">s</span><span class="mord mathtt">t</span><span class="mopen">[</span><span class="mord mathtt">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathtt">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7907770000000001em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathtt mtight">j</span><span class="mbin mtight">−</span><span class="mord mathtt mtight">1</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathtt">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathtt">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></span></span><br>
那就可以直接上代码了：</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#define N 1e5+5
using namespace std;
int zz[N][20]//我一般开20，别问我为什么名字不是st，当时学的时候用的zz
int main(){
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
	scanf(&quot;%d&quot;,&amp;num);
	zz[i][0] = num;
    }
    for(int j=1;j&lt;=19;j++){
    	for (int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++){
    		zz[i][j]=max(zz[i][j-1],zz[i+(1&lt;&lt;(j-1))][j-1]);
		}
	}
</code></pre>
<p>在取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[x,y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>区间的最值时，需要找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>[</mo><mi>e</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">st[x][e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mclose">]</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mo>[</mo><mi>y</mi><mo>−</mo><msup><mn>2</mn><mi>e</mi></msup><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>e</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">st[y-2^e+1][e]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mclose">]</span></span></span></span>的最值并比较。<br>
e是小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的最大2的幂的指数，也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>2</mn><mo>(</mo><mi>y</mi><mo>−</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">log2(y-x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。<br>
具体为什么自己想一想。<br>
于是就出来了：</p>
<pre><code class="language-cpp">for(int i=1;i&lt;=m;i++){
	scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
	int e=log2(y-x);
	printf(&quot;%d\n&quot;,max(zz[x][e],zz[y-(1&lt;&lt;e)+1][e]));
}
</code></pre>
<p><s>我之前把log2写成了log</s></p>
]]></content>
    </entry>
</feed>